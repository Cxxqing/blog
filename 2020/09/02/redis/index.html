<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cxxqing.github.io","root":"/blog/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Redis学习">
<meta property="og:type" content="article">
<meta property="og:title" content="redis">
<meta property="og:url" content="https://cxxqing.github.io/blog/.com/2020/09/02/redis/index.html">
<meta property="og:site_name" content="Carey&#39;s Blog">
<meta property="og:description" content="Redis学习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200902225601453.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200902231157620.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200902233057887.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200902235638078.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903162312046.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903163303464.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903163415290.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903174236733.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903174221560.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903174718423.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903221909900.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903222030989.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903222454706.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903222537678.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903223009976.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903224424203.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903224740736.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903225107747.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903225406634.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903234705904.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903234902991.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200903234952342.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/20200513214125892.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200905202029723.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200905202416347.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/blog/.com/2020/09/02/redis/image-20200907135848524.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200907214034031.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908155357565.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908155445779.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908202135475.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908202214526.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908202535629.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908202614676.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908202708524.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908204416214.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908204431764.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908204714254.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908205004188.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908205103740.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908205423139.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908210526710.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908210826638.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908211219690.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908213223828.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200908213659767.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/graphviz-cd96bfa5c61ef2b8dd69a9b0a97cde047cb722a8.svg">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/20200513215141519.jpg">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200909100642105.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/blog/.com/2020/09/02/redis/image-20200914150922307.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/redis%E6%8C%81%E4%B9%85%E5%8C%961.jpg">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/redis%E6%8C%81%E4%B9%85%E5%8C%962.jpg">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/redis%E6%8C%81%E4%B9%85%E5%8C%963.jpg">
<meta property="og:image" content="https://cxxqing.github.io/blog/blog/.com/2020/09/02/redis/image-20200914153642177.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/blog/.com/2020/09/02/redis/image-20200914154947561.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/blog/.com/2020/09/02/redis/image-20200914155131741.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/blog/.com/2020/09/02/redis/image-20200914155316232.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/blog/.com/2020/09/02/redis/image-20200914160314727.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/pubsub1.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/pubsub2.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E8%AE%A2%E9%98%85%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E5%90%AF%E5%8A%A86379.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E5%90%AF%E5%8A%A86380.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E5%90%AF%E5%8A%A86381.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E9%85%8D%E7%BD%AE%E4%BB%8E%E6%9C%BA.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E6%9F%A5%E7%9C%8Breplication%E9%85%8D%E7%BD%AE.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E6%9F%A5%E7%9C%8Breplication%E9%85%8D%E7%BD%AE2.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AEreplication.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E5%A4%9A%E5%93%A8%E5%85%B5%E7%9B%91%E6%8E%A7Redis.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E5%93%A8%E5%85%B5%E6%B5%8B%E8%AF%95%E6%8C%82%E6%96%AD%E4%B8%BB%E6%9C%BA.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E5%93%A8%E5%85%B5%E6%8A%95%E7%A5%A8.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E4%B8%BB%E6%9C%BA%E5%9B%9E%E6%9D%A5%E5%90%8E%E5%8F%98%E4%BB%8E%E6%9C%BA.png">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.jpeg">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1.jpg">
<meta property="og:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.jpg">
<meta property="article:published_time" content="2020-09-02T14:47:21.000Z">
<meta property="article:modified_time" content="2020-10-03T11:46:43.922Z">
<meta property="article:author" content="Carey">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cxxqing.github.io/blog/2020/09/02/redis/image-20200902225601453.png">

<link rel="canonical" href="https://cxxqing.github.io/blog/.com/2020/09/02/redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>redis | Carey's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="Carey's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Carey's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">40</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/Cxxqing" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cxxqing.github.io/blog/.com/2020/09/02/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="Carey">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carey's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-02 22:47:21" itemprop="dateCreated datePublished" datetime="2020-09-02T22:47:21+08:00">2020-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-03 19:46:43" itemprop="dateModified" datetime="2020-10-03T19:46:43+08:00">2020-10-03</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>47k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>42 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Redis学习"><a href="#Redis学习" class="headerlink" title="Redis学习"></a>Redis学习</h2><a id="more"></a>

<h3 id="Nosql概述"><a href="#Nosql概述" class="headerlink" title="Nosql概述"></a>Nosql概述</h3><h4 id="为什么使用Nosql"><a href="#为什么使用Nosql" class="headerlink" title="为什么使用Nosql"></a>为什么使用Nosql</h4><blockquote>
<p>1、单级Mysql的年代</p>
</blockquote>
<img src="/blog/2020/09/02/redis/image-20200902225601453.png" class>

<p>90年代,一个网站的访问量一般不会太大，单个数据库完全够用。</p>
<p>但如果随着用户增多，网站会出现以下问题：</p>
<ol>
<li>数据量增加到一定程度，单机数据库就放不下了</li>
<li>数据的索引（B+ Tree）,一个机器内存也存放不下</li>
<li>访问量变大后（读写混合），一台服务器承受不住。</li>
</ol>
<p>如果出现上面的情况之一，必须要进行晋级改进技术！</p>
<blockquote>
<p>2、Memcached(缓存) + Mysql + 垂直拆分（读写分离）</p>
</blockquote>
<p>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！</p>
<img src="/blog/2020/09/02/redis/image-20200902231157620.png" class>

<p>发展过程：优化数据结构和索引–&gt;文件缓存（IO）–&gt;Memcached（当时最热门的技术！）</p>
<ol>
<li>优化数据库的数据结构和索引(难度大)</li>
<li>文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了</li>
<li>MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。</li>
</ol>
<blockquote>
<p>3、分库分表 + 水平拆分 + Mysql集群</p>
</blockquote>
<p>==本质：数据库（读，写）==</p>
<p>早些年MyISM：表锁，十分影响效率！高并发下就会出现严重的锁问题</p>
<p>转战Innodb：行琐</p>
<p>慢慢的就开始使用分库分表来解决写的压力！MySQL在那个年代推出了表分区，但这个并没有多少公司使用！</p>
<p>MySQL的集群，很好的满足了当时那个年代的一些需求</p>
<img src="/blog/2020/09/02/redis/image-20200902233057887.png" class>

<blockquote>
<p>4、如今最近的年代</p>
</blockquote>
<p> 如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库无法满足大量数据要求。</p>
<blockquote>
<p>目前一个基本的互联网项目</p>
</blockquote>
<img src="/blog/2020/09/02/redis/image-20200902235638078.png" class>

<blockquote>
<p>为什么要用NoSQL ？</p>
</blockquote>
<p>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！<br>这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！</p>
<h4 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h4><p><strong>NoSQL = Not Only SQL（不仅仅是SQL）</strong></p>
<p>关系型数据库：行+列，同一个表下数据的结构是一样的。</p>
<p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p>
<p>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p>
<blockquote>
<p>NoSQL特点</p>
</blockquote>
<ol>
<li>方便扩展（数据之间没有关系，很好扩展！）</li>
<li>大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</li>
<li>数据类型是多样型的！（不需要事先设计数据库，随取随用）</li>
<li>传统的 RDBMS 和 NoSQL</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">传统的 RDBMS(关系型数据库)</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都存在单独的表中 row col</span><br><span class="line">- 操作，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 基础的事务</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NoSQL</span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库（社交关系）</span><br><span class="line">- 最终一致性</span><br><span class="line">- CAP定理和BASE	</span><br><span class="line">- 高性能，高可用，高扩展</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>了解：3V + 3高</p>
</blockquote>
<p>大数据时代的3V ：主要是<strong>描述问题</strong>的</p>
<ol>
<li>海量Velume</li>
<li>多样Variety</li>
<li>实时Velocity</li>
</ol>
<p>大数据时代的3高 ： 主要是<strong>对程序的要求</strong></p>
<ol>
<li>高并发</li>
<li>高可扩</li>
<li>高性能</li>
</ol>
<p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。</p>
<h4 id="阿里巴巴演进分析"><a href="#阿里巴巴演进分析" class="headerlink" title="阿里巴巴演进分析"></a>阿里巴巴演进分析</h4><img src="/blog/2020/09/02/redis/image-20200903162312046.png" class>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 商品信息</span><br><span class="line">  一般存放在关系型数据库：Mysql,阿里巴巴使用的Mysql都是经过内部改动的。</span><br><span class="line"></span><br><span class="line"># 商品描述、评论(文字居多)</span><br><span class="line">  文档型数据库：MongoDB</span><br><span class="line"></span><br><span class="line"># 图片</span><br><span class="line">  分布式文件系统 FastDFS</span><br><span class="line">  - 淘宝：TFS</span><br><span class="line">  - Google: GFS</span><br><span class="line">  - Hadoop: HDFS</span><br><span class="line">  - 阿里云: oss</span><br><span class="line"></span><br><span class="line"># 商品的关键字 用于搜索</span><br><span class="line">  - 搜索引擎：solr,elasticsearch</span><br><span class="line">  - 阿里：Isearch 多隆</span><br><span class="line"></span><br><span class="line"># 商品热门的波段信息</span><br><span class="line">  - 内存数据库：Redis，Tair，Memcache</span><br><span class="line"></span><br><span class="line"># 商品交易，外部支付接口</span><br><span class="line">  - 第三方应用</span><br></pre></td></tr></table></figure>

<p>大型互联网应用问题：</p>
<ul>
<li>数据类型太多了</li>
<li>数据源繁多，经常重构</li>
<li>数据要改造，大面积改造麻烦</li>
</ul>
<p>解决问题：</p>
<img src="/blog/2020/09/02/redis/image-20200903163303464.png" class>

<img src="/blog/2020/09/02/redis/image-20200903163415290.png" class>

<h4 id="Nosql的四大分类"><a href="#Nosql的四大分类" class="headerlink" title="Nosql的四大分类"></a>Nosql的四大分类</h4><p><strong>KV键值对：</strong></p>
<ul>
<li>新浪：Redis</li>
<li>美团：Redis + Tair</li>
<li>阿里、百度：Redis + Memcache</li>
</ul>
<p><strong>文档型数据库（bson数据格式和json一样）：</strong></p>
<ul>
<li><strong>MongoDB</strong>(一般必须要掌握)<ul>
<li>基于分布式文件存储的数据库。C++编写，用于处理大量文档。</li>
<li>MongoDB是介于关系型数据库和非关系型数据库的中间产品。MongoDB是非关系型数据库中功能最丰富的，最像关系型数据库的数据库。</li>
</ul>
</li>
<li>ConthDB</li>
</ul>
<p><strong>列存储数据库</strong></p>
<ul>
<li>HBase(大数据必学)</li>
<li>分布式文件系统</li>
</ul>
<p><strong>图关系数据库</strong></p>
<p>用于广告推荐，社交网络</p>
<ul>
<li>Neo4j、InfoGrid</li>
</ul>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th align="center"><strong>Examples举例</strong></th>
<th align="center"><strong>典型应用场景</strong></th>
<th align="center"><strong>数据模型</strong></th>
<th align="center"><strong>优点</strong></th>
<th align="center"><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>键值对（key-value）</strong></td>
<td align="center">Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB</td>
<td align="center">内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。</td>
<td align="center">Key 指向 Value 的键值对，通常用hash table来实现</td>
<td align="center">查找速度快</td>
<td align="center">数据无结构化，通常只被当作字符串或者二进制数据</td>
</tr>
<tr>
<td><strong>列存储数据库</strong></td>
<td align="center">Cassandra, HBase, Riak</td>
<td align="center">分布式的文件系统</td>
<td align="center">以列簇式存储，将同一列数据存在一起</td>
<td align="center">查找速度快，可扩展性强，更容易进行分布式扩展</td>
<td align="center">功能相对局限</td>
</tr>
<tr>
<td><strong>文档型数据库</strong></td>
<td align="center">CouchDB, MongoDb</td>
<td align="center">Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td>
<td align="center">Key-Value对应的键值对，Value为结构化数据</td>
<td align="center">数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td>
<td align="center">查询性能不高，而且缺乏统一的查询语法。</td>
</tr>
<tr>
<td><strong>图形(Graph)数据库</strong></td>
<td align="center">Neo4J, InfoGrid, Infinite Graph</td>
<td align="center">社交网络，推荐系统等。专注于构建关系图谱</td>
<td align="center">图结构</td>
<td align="center">利用图结构相关算法。比如最短路径寻址，N度关系查找等</td>
<td align="center">很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群</td>
</tr>
</tbody></table>
<h3 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>Redis是什么？</p>
</blockquote>
<p>Redis（Remote Dictionary Server )，即远程字典服务。</p>
<p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value数据库</strong>，并提供多种语言的API。</p>
<p>与memcached一样，为了保证效率，<strong>数据都是缓存在内存中</strong>。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<blockquote>
<p>Redis能该干什么？</p>
</blockquote>
<p> 1、内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</p>
<p>2、效率高、可用于高速缓存</p>
<p>3、发布订阅系统</p>
<p>4、地图信息分析</p>
<p>5、计时器、计数器(eg：浏览量)</p>
<p>……</p>
<blockquote>
<p>特性</p>
</blockquote>
<p>1、多样的数据类型</p>
<p>2、持久化</p>
<p>3、集群</p>
<p>4、事务</p>
<p>……</p>
<blockquote>
<p>环境搭建</p>
</blockquote>
<p>官网：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p>
<p>推荐使用Linux服务器学习。</p>
<h4 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h4><p>1、下载安装包：<a href="https://github.com/dmajkic/redis" target="_blank" rel="noopener">https://github.com/dmajkic/redis</a></p>
<p>2、下载完毕得到压缩包</p>
<p>3、解压到自己电脑上的环境目录</p>
<p>4、开启Redis，双击运行服务即可redis-server.exe</p>
<img src="/blog/2020/09/02/redis/image-20200903174236733.png" class>

<p>5、使用Redis客户端来连接Redis</p>
<img src="/blog/2020/09/02/redis/image-20200903174221560.png" class>

<h4 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h4><p>1、下载安装包</p>
<img src="/blog/2020/09/02/redis/image-20200903174718423.png" class>

<p>2、解压Redis的安装包！程序/opt</p>
<img src="/blog/2020/09/02/redis/image-20200903221909900.png" class>

<p>3、进入解压后的文件，可以看到Redis的配置文件</p>
<img src="/blog/2020/09/02/redis/image-20200903222030989.png" class>

<p>4、基本的环境安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<img src="/blog/2020/09/02/redis/image-20200903222454706.png" class>

<img src="/blog/2020/09/02/redis/image-20200903222537678.png" class>

<p>5、redis的默认安装路径<code>/usr/local/bin</code></p>
<img src="/blog/2020/09/02/redis/image-20200903223009976.png" class>

<p>6、将Redis配置文件     复制到我们当前目录下</p>
<img src="/blog/2020/09/02/redis/image-20200903224424203.png" class>

<p>7、Redis默认不是后台启动的，修改配置文件！</p>
<img src="/blog/2020/09/02/redis/image-20200903224740736.png" class>

<p>8、启动Redis服务</p>
<img src="/blog/2020/09/02/redis/image-20200903225107747.png" class>

<p>9、使用redis-cli进行连接测试</p>
<img src="/blog/2020/09/02/redis/image-20200903225406634.png" class>

<p>10、查看redis的进程是否开启！</p>
<img src="/blog/2020/09/02/redis/image-20200903234705904.png" class>

<p>11、如何关闭Redis服务</p>
<img src="/blog/2020/09/02/redis/image-20200903234902991.png" class>

<p>12、再次查看进程是否存在</p>
<img src="/blog/2020/09/02/redis/image-20200903234952342.png" class>

<p>13、后面我们会使用单机多Redis启动集群测试！</p>
<h4 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h4><p><strong>redis-benchmark：</strong>Redis官方提供的性能测试工具，参数选项如下：</p>
<img src="/blog/2020/09/02/redis/20200513214125892.png" class>

<p><strong>简单测试：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试：100个并发连接 100000请求</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br></pre></td></tr></table></figure>

<img src="/blog/2020/09/02/redis/image-20200905202029723.png" class>

<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>redis默认有16个数据库</p>
<img src="/blog/2020/09/02/redis/image-20200905202416347.png" class>

<p>默认使用的第0个;</p>
<p>16个数据库为：DB 0~DB 15<br>默认使用DB 0 ，可以使用<code>select n</code>切换到DB n，<code>dbsize</code>可以查看当前数据库的大小，与key数量相关。</p>
<p>切换数据库、查看数据库大小</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SELECT 3         #切换数据库</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; DBSIZE		#查看数据库大小</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>查看数据库所有的<code>key *</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; keys *	#查看数据库所有的key</span><br><span class="line">1) "name"</span><br></pre></td></tr></table></figure>

<p>清除当前数据库<code>flushdb</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; flushdb    #清除当前数据库</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure>

<p>清除全部的数据库<code>FLUSHALL</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHALL	#清除全部的数据库</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure>

<p><code>keys *</code> ：查看当前数据库中所有的key。</p>
<p><code>flushdb</code>：清空当前数据库中的键值对。</p>
<p><code>flushall</code>：清空所有数据库的键值对。</p>
<p><strong>Redis是单线程的，Redis是基于内存操作的。</strong></p>
<p>所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。</p>
<p><strong>Redis为什么单线程还这么快？</strong></p>
<ul>
<li><p>误区1：高性能的服务器一定是多线程的？</p>
</li>
<li><p>误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</p>
<p>速度：CPU&gt;内存&gt;磁盘</p>
</li>
</ul>
<p>核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。</p>
<h3 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h3><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings" target="_blank" rel="noopener">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes" target="_blank" rel="noopener">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists" target="_blank" rel="noopener">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets" target="_blank" rel="noopener">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets" target="_blank" rel="noopener">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps" target="_blank" rel="noopener">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs" target="_blank" rel="noopener">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html" target="_blank" rel="noopener">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html" target="_blank" rel="noopener">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html" target="_blank" rel="noopener">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html" target="_blank" rel="noopener">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html" target="_blank" rel="noopener">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html" target="_blank" rel="noopener">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html" target="_blank" rel="noopener">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">分区（Cluster）</a>提供高可用性（high availability）。</p>
<h4 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h4><p>下面学习的命令：</p>
<ul>
<li><code>exists key</code>：判断键是否存在</li>
<li><code>del key</code>：删除键值对</li>
<li><code>move key db</code>：将键值对移动到指定数据库</li>
<li><code>expire key second</code>：设置键值对的过期时间</li>
<li><code>type key</code>：查看value的数据类型</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *		# 查看所有的key</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; set name carey # set key</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "name"</span><br><span class="line">127.0.0.1:6379&gt; set age 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "name"</span><br><span class="line">2) "age"</span><br><span class="line">127.0.0.1:6379&gt; EXISTS name		# 判断当前的key是否存在</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS name1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; move name 1		# 移动当前的key到指定的数据库</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS name</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "age"</span><br><span class="line">127.0.0.1:6379&gt; set name carey</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "name"</span><br><span class="line">2) "age"</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"carey"</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE name 10	# 设置key的过期时间，单位是秒</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name	# 查看当前key的剩余时间</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(integer) -2</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; set name carey</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "name"</span><br><span class="line">2) "age"</span><br><span class="line">127.0.0.1:6379&gt; type name	# 查看当前key的一个类型</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; type age</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; SELECT 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) "name"</span><br><span class="line">127.0.0.1:6379[1]&gt; del name   # 删除当前key</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure>

<p>关于<code>TTL</code>命令</p>
<p>Redis的key，通过TTL命令返回key的过期时间，一般来说有3种：</p>
<ol>
<li>当前key没有设置过期时间，所以会返回-1.</li>
<li>当前key有设置过期时间，而且key已经过期，所以会返回-2.</li>
<li>当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</li>
</ol>
<p>关于重命名<code>RENAME</code>和<code>RENAMENX</code></p>
<ul>
<li><code>RENAME key newkey</code>修改 key 的名称</li>
<li><code>RENAMENX key newkey</code>仅当 newkey 不存在时，将 key 改名为 newkey 。</li>
</ul>
<p>更多命令学习：<a href="https://www.redis.net.cn/order/" target="_blank" rel="noopener">https://www.redis.net.cn/order/</a></p>
<h4 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h4><p>普通的set、get直接略过。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>APPEND key value</code></td>
<td>向指定的key的value后追加字符串<br>如果当前key不存在，就相当于set key</td>
<td>127.0.0.1:6379[1]&gt; set key1 v1<br>OK<br>127.0.0.1:6379[1]&gt; APPEND key1 “hello”<br>(integer) 7<br>127.0.0.1:6379[1]&gt; get key1<br>“v1hello”</td>
</tr>
<tr>
<td><code>DECR/INCR key</code></td>
<td>将指定key的value数值进行+1/-1(仅对于数字)</td>
<td>127.0.0.1:6379&gt; set views 5<br>OK<br>127.0.0.1:6379&gt; get views<br>“5”<br>127.0.0.1:6379&gt; INCR views<br>(integer) 6<br>127.0.0.1:6379&gt; DECR views<br>(integer) 5</td>
</tr>
<tr>
<td><code>INCRBY/DECRBY key n</code></td>
<td>按指定的步长对数值进行加减</td>
<td>127.0.0.1:6379&gt; get views<br>“-1”<br>127.0.0.1:6379&gt; INCRBY views 10<br>(integer) 9<br>127.0.0.1:6379&gt; DECRBY views 5<br>(integer) 4<br>127.0.0.1:6379&gt; get views<br>“4”</td>
</tr>
<tr>
<td><code>INCRBYFLOAT key n</code></td>
<td>为数值加上浮点型数值</td>
<td>127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 “20.2”</td>
</tr>
<tr>
<td><code>STRLEN key</code></td>
<td>获取key保存值的字符串长度</td>
<td>127.0.0.1:6379&gt; set msg ‘hello world’<br>OK<br>127.0.0.1:6379&gt; get msg<br>“hello world”<br>127.0.0.1:6379&gt; STRLEN msg<br>(integer) 11</td>
</tr>
<tr>
<td><code>GETRANGE key start end</code></td>
<td>按起止位置获取字符串<br>（闭区间，起止位置都取）, <br> end取-1的话，是取整个字符串</td>
<td>127.0.0.1:6379&gt; set key1 “hello,carey”<br>OK<br>127.0.0.1:6379&gt; get key1<br>“hello,carey”<br>127.0.0.1:6379&gt; GETRANGE key1 0 3<br>“hell”<br>127.0.0.1:6379&gt; GETRANGE key1 0 -1<br>“hello,carey”</td>
</tr>
<tr>
<td><code>SETRANGE key offset value</code></td>
<td>用指定的value 替换key中 offset开始的值</td>
<td>127.0.0.1:6379&gt; set key2 abcdefg<br>OK<br>127.0.0.1:6379&gt; get key2<br>“abcdefg”<br>127.0.0.1:6379&gt; SETRANGE key2 1 xx<br>(integer) 7<br>127.0.0.1:6379&gt; get key2<br>“axxdefg”</td>
</tr>
<tr>
<td><code>GETSET key value</code></td>
<td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
<td>127.0.0.1:6379&gt; GETSET msg test “hello world”</td>
</tr>
<tr>
<td><code>SETNX key value</code></td>
<td>仅当key不存在时进行set<br>(在分布式锁中常常使用)</td>
<td>127.0.0.1:6379&gt; SETNX mykey “redis”<br>(integer) 1<br>127.0.0.1:6379&gt; SETNX mykey “MongoDB”<br>(integer) 0<br>127.0.0.1:6379&gt; get mykey<br>“redis”</td>
</tr>
<tr>
<td><code>SETEX key seconds value</code></td>
<td>set 键值对并设置过期时间</td>
<td>127.0.0.1:6379&gt; SETEX key3 30 “hello”<br>OK<br>127.0.0.1:6379&gt; ttl key3<br>(integer) 25<br>127.0.0.1:6379&gt; get key3<br>“hello”<br>127.0.0.1:6379&gt; keys *<br>1) “key2”<br>2) “key1”<br>3) “msg”<br>4) “mykey”<br>127.0.0.1:6379&gt; ttl key3<br>(integer) -2</td>
</tr>
<tr>
<td><code>MSET key1 value1 [key2 value2..]</code></td>
<td>批量set键值对</td>
<td>127.0.0.1:6379&gt; keys *<br>(empty array)<br>127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) “k3”<br>2) “k2”<br>3) “k1”<br>127.0.0.1:6379&gt; MGET k1 k2 k3<br>1) “v1”<br>2) “v2”<br>3) “v3”</td>
</tr>
<tr>
<td><code>MSETNX key1 value1 [key2 value2..]</code></td>
<td>批量设置键值对，仅当参数中所有的key都不存在时执行,(示例中k1已经创建过了)</td>
<td>127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4<br>(integer) 0<br>127.0.0.1:6379&gt; get k4<br>(nil)</td>
</tr>
<tr>
<td><code>MGET key1 [key2..]</code></td>
<td>批量获取多个key保存的值</td>
<td>127.0.0.1:6379&gt; MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”</td>
</tr>
<tr>
<td><code>PSETEX key milliseconds value</code></td>
<td>和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，</td>
<td></td>
</tr>
<tr>
<td><code>getset key value</code></td>
<td>先get后set，<br>如果不存在值，则返回nil，<br>如果存在值，获取原来的值。  <br>最后设置新的值。</td>
<td>127.0.0.1:6379&gt; getset db redis<br>(nil)<br>127.0.0.1:6379&gt; get db<br>“redis”<br>127.0.0.1:6379&gt; getset db mongodb<br>“redis”<br>127.0.0.1:6379&gt; get db<br>“mongodb”</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对象</span></span><br><span class="line">127.0.0.1:6379&gt; set user:1 &#123;name:zhangsan,age:3&#125; # 设置一个user:1 对象 值为 Jason字符来保存一个对象！</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> user:&#123;id&#125;:&#123;field&#125;</span></span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line">"&#123;name:zhangsan,age:3&#125;"</span><br><span class="line">127.0.0.1:6379&gt; del user:1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) "zhangsan"</span><br><span class="line">2) "2"</span><br></pre></td></tr></table></figure>

<p>String类似的使用场景：value除了是字符串还可以是数字，用途举例：</p>
<ul>
<li>计数器</li>
<li>统计多单位的数量：uid:123666：follow 0</li>
<li>粉丝数</li>
<li>对象存储缓存</li>
</ul>
<h4 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h4><blockquote>
<p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p>
</blockquote>
<p>在Redis里面，我们可以把list玩成 栈 、队列、 双端队列</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list one	# 将一个值或者多个值，插入到列表头部（左）</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list two</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1	# 获取list中的值</span><br><span class="line">1) "three"</span><br><span class="line">2) "two"</span><br><span class="line">3) "one"</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 1		# 通过区间获取具体的值</span><br><span class="line">1) "three"</span><br><span class="line">2) "two"</span><br><span class="line">127.0.0.1:6379&gt; RPUSH list righr	# 将一个值或者多个值，插入到列表尾部（右）</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "three"</span><br><span class="line">2) "two"</span><br><span class="line">3) "one"</span><br><span class="line">4) "righr"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "three"</span><br><span class="line">2) "two"</span><br><span class="line">3) "one"</span><br><span class="line">4) "righr"</span><br><span class="line">127.0.0.1:6379&gt; LPOP list	# 移除list的第一个元素</span><br><span class="line">"three"</span><br><span class="line">127.0.0.1:6379&gt; RPOP list	# 移除list的最后一个元素</span><br><span class="line">"righr"</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "two"</span><br><span class="line">2) "one"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "two"</span><br><span class="line">2) "one"</span><br><span class="line">127.0.0.1:6379&gt; LINDEX list 1	# 通过下标获得list中的某一个值</span><br><span class="line">"one"</span><br><span class="line">127.0.0.1:6379&gt; LINDEX list 0</span><br><span class="line">"two"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list one</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list two</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; LLEN list	# 返回列表的长度</span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list three</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "three"</span><br><span class="line">2) "three"</span><br><span class="line">3) "two"</span><br><span class="line">4) "one"</span><br><span class="line">127.0.0.1:6379&gt; LREM list 1 three	# 移除list集合中指定个数的value，精确匹配</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list three</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; LREM list 2 three</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "two"</span><br><span class="line">2) "one"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; FLUSHALL</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist "hello"</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist "hello1"</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist "hello2"</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist "hello3"</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; LTRIM mylist 1 2	# 通过下标截取指定的长度，这个list已经被改变了，截断了只剩下截取的元素 </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) "hello1"</span><br><span class="line">2) "hello2"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###################################################################</span></span></span><br><span class="line">rpoplpush # 移除列表的最后一个元素，将他移动到新的列表中</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist "hello"</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist "hello1"</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist "hello2"</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH mylist myotherlist	# 移除列表的最后一个元素，将他移动到新的列表中</span><br><span class="line">"hello2"</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1 # 查看原来的列表</span><br><span class="line">1) "hello"</span><br><span class="line">2) "hello1"</span><br><span class="line">127.0.0.1:6379&gt; LRANGE myotherlist 0 -1 # 查看目标列表中，确实存在该值</span><br><span class="line">1) "hello2"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">lset # 将列表中指定下标的值替换为另外一个值，更新操作</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; EXISTS list	#判断列表是否存在</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item	# 如果不存在列表我们去更新就会报错</span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lpush list value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 0</span><br><span class="line">1) "value1"</span><br><span class="line">127.0.0.1:6379&gt; LSET list 0 item	# 如果存在，更新当前下标的值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 0</span><br><span class="line">1) "item"</span><br><span class="line">127.0.0.1:6379&gt; LSET list 1 other	# 如果不存在，则会报错</span><br><span class="line">(error) ERR index out of range</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">linsert # 将某个具体的value插入到列表中某个元素的前面或者后面</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist "hello"</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist "world"</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist before "world" "other"</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) "hello"</span><br><span class="line">2) "other"</span><br><span class="line">3) "world"</span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist after "world" "new"</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) "hello"</span><br><span class="line">2) "other"</span><br><span class="line">3) "world"</span><br><span class="line">4) "new"</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>list实际上是一个链表，before Node after , left, right 都可以插入值</li>
<li><strong>如果key不存在，则创建新的链表</strong></li>
<li>如果key存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在</li>
<li>在两边插入或者改动值，效率最高！修改中间元素，效率相对较低</li>
</ul>
<p><strong>应用：</strong></p>
<p><strong>消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop）</strong></p>
<h4 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h4><blockquote>
<p>Redis的Set是<strong>string类型</strong>的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
</blockquote>
<p>set中的值不能重复</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset "hello"		# set集合中添加元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset "carey"</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset "excellentcarey"</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset		# 查看指定set的所有值</span><br><span class="line">1) "carey"</span><br><span class="line">2) "excellentcarey"</span><br><span class="line">3) "hello"</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset carey	# 判断某一个值是不是在set集合中</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset word</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; SCARD myset		# 获取set集合中的内容元素个数</span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; SREM myset hello	# 移除set集合中的指定元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SCARD myset</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) "carey"</span><br><span class="line">2) "excellentcarey"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) "carey"</span><br><span class="line">2) "excellentcarey"</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset	# 随机抽选出一个元素</span><br><span class="line">"excellentcarey"</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line">"excellentcarey"</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line">"carey"</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 1</span><br><span class="line">1) "carey"</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 2		# 随机抽选出指定个数的元素</span><br><span class="line">1) "carey"</span><br><span class="line">2) "excellentcarey"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) "carey"</span><br><span class="line">2) "carey2"</span><br><span class="line">3) "excellentcarey"</span><br><span class="line">127.0.0.1:6379&gt; SPOP myset	# 随机删除一些set集合中的元素！</span><br><span class="line">"excellentcarey"</span><br><span class="line">127.0.0.1:6379&gt; SPOP myset</span><br><span class="line">"carey"</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) "carey2"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">SMOVE	# 将一个指定的值，移动到另外一个set集合中</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SADD myset "hello" </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD myset "world"</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD myset "carey"</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 "set2"</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMOVE myset myset2 "carey"  # 将一个指定的值，移动到另外一个set集合</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) "hello"</span><br><span class="line">2) "world"</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset2</span><br><span class="line">1) "carey"</span><br><span class="line">2) "set2"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################</span></span></span><br><span class="line">数字集合类：</span><br><span class="line">- 差集	SDIFF</span><br><span class="line">- 交集	SINTER</span><br><span class="line">- 并集	SUNION</span><br><span class="line">127.0.0.1:6379&gt; SADD key1 a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD key1 b</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD key1 c</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD key2 c</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD key2 d</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD key2 e</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SDIFF key1 key2		# 差集</span><br><span class="line">1) "b"</span><br><span class="line">2) "a"</span><br><span class="line">127.0.0.1:6379&gt; SINTER key1 key2	# 交集	共同好友就可以这样实现</span><br><span class="line">1) "c"</span><br><span class="line">127.0.0.1:6379&gt; SUNION key1 key2	# 并集</span><br><span class="line">1) "a"</span><br><span class="line">2) "c"</span><br><span class="line">3) "e"</span><br><span class="line">4) "b"</span><br><span class="line">5) "d"</span><br></pre></td></tr></table></figure>

<h4 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h4><blockquote>
<p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET myhash field1 carey	# set一个具体 key-value</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HGET myhash field1	# 获取一个字段值</span><br><span class="line">"carey"</span><br><span class="line">127.0.0.1:6379&gt; HMSET myhash field1 hello field2 world	# set多个key-value</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HMGET myhash field1 field2	# 获取多个字段值</span><br><span class="line">1) "hello"</span><br><span class="line">2) "world"</span><br><span class="line">127.0.0.1:6379&gt; HGETALL myhash	# 获取全部的数据</span><br><span class="line">1) "field1"</span><br><span class="line">2) "hello"</span><br><span class="line">3) "field2"</span><br><span class="line">4) "world"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; HDEL myhash field1		# 删除hash指定key字段，对应的value值也就消失了</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HGETALL myhash</span><br><span class="line">1) "field2"</span><br><span class="line">2) "world"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; HMSET myhash field1 hello field2 world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HGETALL myhash</span><br><span class="line">1) "field2"</span><br><span class="line">2) "world"</span><br><span class="line">3) "field1"</span><br><span class="line">4) "hello"</span><br><span class="line">127.0.0.1:6379&gt; HLEN myhash		# 获取hash表的字段数量</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash field1	# 判断hash中指定字段是否存在</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash field3</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; HKEYS myhash	# 只获得所有field</span><br><span class="line">1) "field2"</span><br><span class="line">2) "field1"</span><br><span class="line">127.0.0.1:6379&gt; HVALS myhash	# 只获得所有value</span><br><span class="line">1) "world"</span><br><span class="line">2) "hello"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##################################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; HSET myhash field3 5	# 指定增量</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash field3 1	</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash field3 -1</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; HSETNX myhash field4 hello	# 如果不存在则可以设置</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HSETNX myhash field4 world	# 如果存在则不可以设置</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p> Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！<strong>Hash更适合于对象的存储，Sring更加适合字符串存储！</strong></p>
<h4 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h4><blockquote>
<p>不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>score相同：按字典顺序排序</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
</blockquote>
<p>在set的基础上，增加了一个值，set k1 v1      zset k1 score1 v1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD myset 1 one	# 添加一个值</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZADD myset 2 two 3 three	# 添加多个值</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myset 0 -1</span><br><span class="line">1) "one"</span><br><span class="line">2) "two"</span><br><span class="line">3) "three"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##########################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; ZADD salary 2500 xiaohong	# 添加用户</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZADD salary 5000 zhangsan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZADD salary 500 carey</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> ZRANGEBYSCORE key min max</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf	# 显示全部的用户 从小到大</span><br><span class="line">1) "carey"</span><br><span class="line">2) "xiaohong"</span><br><span class="line">3) "zhangsan"</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary 0 -1</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE salary 0 -1	# 从大到小进行排序  ，要用ZREVRANGE</span><br><span class="line">1) "zhangsan"</span><br><span class="line">2) "xiaohong"</span><br><span class="line">3) "carey"</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores	# 显示全部的用户 从小到大并附带成绩</span><br><span class="line">1) "carey"</span><br><span class="line">2) "500"</span><br><span class="line">3) "xiaohong"</span><br><span class="line">4) "2500"</span><br><span class="line">5) "zhangsan"</span><br><span class="line">6) "5000"</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores	# 显示工资小于2500员工的升序排列</span><br><span class="line">1) "carey"</span><br><span class="line">2) "500"</span><br><span class="line">3) "xiaohong"</span><br><span class="line">4) "2500"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##########################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE salary 0 -1</span><br><span class="line">1) "carey"</span><br><span class="line">2) "xiaohong"</span><br><span class="line">3) "zhangsan"</span><br><span class="line">127.0.0.1:6379&gt; ZREM salary xiaohong	# 移除有序集合中的指定元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE salary 0 -1</span><br><span class="line">1) "carey"</span><br><span class="line">2) "zhangsan"</span><br><span class="line">127.0.0.1:6379&gt; ZCARD salary	# 获取有序集合的个数</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##########################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 world 3 carey</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myset 1 3	#获取指定区间的成员数量</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myset 1 2</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<p>应用案例：</p>
<ul>
<li>set排序 存储班级成绩表 工资表排序！</li>
<li>普通消息，1.重要消息 2.带权重进行判断</li>
<li>排行榜应用实现，取Top N测试</li>
</ul>
<h3 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h3><h4 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial(地理位置)"></a>Geospatial(地理位置)</h4><blockquote>
<p>使用经纬度定位地理坐标并用一个<strong>有序集合zset保存</strong>，所以zset命令也可以使用</p>
</blockquote>
<p><img src="/blog/blog/.com/2020/09/02/redis/image-20200907135848524.png" alt="image-20200907135848524"></p>
<blockquote>
<p>geoadd</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> geoadd 添加地理位置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 规则：两极无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数 key 值（纬度、经度、名称）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 有效的经度从-180度到180度。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 有效的纬度从-85.05112878度到85.05112878度。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当坐标位置超出上述指定范围时，该命令将会返回一个错误。</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GEOADD china:city 114.085947 22.547 shenzhen</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; GEOADD china:city 113.280637 23.125178 shanghai</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; GEOADD china:city 116.355733 23.543778 jieyang 113.760234 23.048884 dongguang</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; GEOADD china:city 113.280637 23.125178 guangzhou 116.405285 39.904989 beijing</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>geopos</p>
</blockquote>
<p>获得当前定位：一定是一个坐标值</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEOPOS china:city jieyang	# 获取指定的城市的经度和纬度</span><br><span class="line">1) 1) "116.3557317852973938"</span><br><span class="line">   2) "23.54377903364970592"</span><br><span class="line">127.0.0.1:6379&gt; GEOPOS china:city shenzhen shanghai</span><br><span class="line">1) 1) "114.08594459295272827"</span><br><span class="line">   2) "22.54699993773966327"</span><br><span class="line">2) 1) "113.28063815832138062"</span><br><span class="line">   2) "23.12517743834835215"</span><br></pre></td></tr></table></figure>

<blockquote>
<p>geodist</p>
</blockquote>
<p>两个人之间的位置</p>
<p>指定单位的参数 unit 必须是以下单位的其中一个：</p>
<ul>
<li><strong>m</strong> 表示单位为米。</li>
<li><strong>km</strong> 表示单位为千米。</li>
<li><strong>mi</strong> 表示单位为英里。</li>
<li><strong>ft</strong> 表示单位为英尺。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km	# 查看北京到上海的直线距离</span><br><span class="line">"1889.3706"</span><br></pre></td></tr></table></figure>

<blockquote>
<p>georadius 以给定的经纬度为中心，找出某一半径内的元素</p>
</blockquote>
<p>通过<code>georadius</code>就可以完成 <strong>附近的人</strong>功能</p>
<p>withcoord:带上坐标</p>
<p>withdist:带上距离，单位与半径单位相同</p>
<p>COUNT n : 只显示前n个(按距离递增排序)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km # 以100，30这个经纬度为中心，寻找方圆1000km以内的城市</span><br><span class="line">1) "shenzhen"</span><br><span class="line">2) "guangzhou"</span><br><span class="line">3) "shanghai"</span><br><span class="line">4) "dongguang"</span><br><span class="line">5) "jieyang"</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 900 km</span><br><span class="line">1) "guangzhou"</span><br><span class="line">2) "shanghai"</span><br><span class="line">3) "dongguang"</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 900 km withdist	# 显示到中心位置的距离</span><br><span class="line">1) 1) "guangzhou"</span><br><span class="line">   2) "831.2636"</span><br><span class="line">2) 1) "shanghai"</span><br><span class="line">   2) "831.2636"</span><br><span class="line">3) 1) "dongguang"</span><br><span class="line">   2) "858.7679"</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 900 km withcoord # 显示他人的定位信息</span><br><span class="line">1) 1) "guangzhou"</span><br><span class="line">   2) 1) "113.28063815832138062"</span><br><span class="line">      2) "23.12517743834835215"</span><br><span class="line">2) 1) "shanghai"</span><br><span class="line">   2) 1) "113.28063815832138062"</span><br><span class="line">      2) "23.12517743834835215"</span><br><span class="line">3) 1) "dongguang"</span><br><span class="line">   2) 1) "113.76023322343826294"</span><br><span class="line">      2) "23.04888486617340959"</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 900 km withdist withcoord count 1	# 筛选出指定的结果</span><br><span class="line">1) 1) "guangzhou"</span><br><span class="line">   2) "831.2636"</span><br><span class="line">   3) 1) "113.28063815832138062"</span><br><span class="line">      2) "23.12517743834835215"</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 900 km withdist withcoord count 2</span><br><span class="line">1) 1) "guangzhou"</span><br><span class="line">   2) "831.2636"</span><br><span class="line">   3) 1) "113.28063815832138062"</span><br><span class="line">      2) "23.12517743834835215"</span><br><span class="line">2) 1) "shanghai"</span><br><span class="line">   2) "831.2636"</span><br><span class="line">   3) 1) "113.28063815832138062"</span><br><span class="line">      2) "23.12517743834835215"</span><br></pre></td></tr></table></figure>

<blockquote>
<p>georadiusbymember</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 找出位于指定元素周围的其他元素</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city guangzhou 100 km</span><br><span class="line">1) "guangzhou"</span><br><span class="line">2) "shanghai"</span><br><span class="line">3) "dongguang"</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city jieyang 400 km </span><br><span class="line">1) "shenzhen"</span><br><span class="line">2) "guangzhou"</span><br><span class="line">3) "shanghai"</span><br><span class="line">4) "dongguang"</span><br><span class="line">5) "jieyang"</span><br></pre></td></tr></table></figure>

<blockquote>
<p>geohash</p>
</blockquote>
<p>该命令将返回11个字符的Geohash字符串</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，则距离就越近</span></span><br><span class="line">127.0.0.1:6379&gt; geohash china:city beijing shanghai </span><br><span class="line">1) "wx4g0b7xrt0"</span><br><span class="line">2) "ws0e9cb3yj0"</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GEO底层的实现原理其实就是Zset！我们可以使用Zset命令来操作geo！</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGE china:city 0 -1	# 查看地图中全部的元素</span><br><span class="line">1) "shenzhen"</span><br><span class="line">2) "guangzhou"</span><br><span class="line">3) "shanghai"</span><br><span class="line">4) "dongguang"</span><br><span class="line">5) "jieyang"</span><br><span class="line">6) "beijing"</span><br><span class="line">127.0.0.1:6379&gt; ZREM china:city beijing # 移除指定的元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE china:city 0 -1</span><br><span class="line">1) "shenzhen"</span><br><span class="line">2) "guangzhou"</span><br><span class="line">3) "shanghai"</span><br><span class="line">4) "dongguang"</span><br><span class="line">5) "jieyang"</span><br></pre></td></tr></table></figure>

<h4 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog(基数统计)"></a>Hyperloglog(基数统计)</h4><blockquote>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p>
<p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>其底层使用string数据类型</p>
</blockquote>
<p><strong>什么是基数？</strong></p>
<p>基数是数据集中不重复的元素的个数</p>
<p><strong>应用场景：</strong></p>
<p>网页的访问量（UV）：一个用户多次访问，也只能算作一个人。</p>
<blockquote>
<p>传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是<strong>计数</strong>，Hyperloglog就能帮助我们利用最小的空间完成。</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>PFADD key element1 [elememt2..]</code></td>
<td>添加指定元素到 HyperLogLog 中</td>
</tr>
<tr>
<td><code>PFCOUNT key [key]</code></td>
<td>返回给定 HyperLogLog 的基数估算值。</td>
</tr>
<tr>
<td><code>PFMERGE destkey sourcekey [sourcekey..]</code></td>
<td>将多个 HyperLogLog 合并为一个 HyperLogLog</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFADD mykey a b c d e f g h i j	# 创建第一组元素 mykey</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey	# 统计mykey 元素的基数数量</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; PFADD mykey2 i j z x c v b n m	# 创建第二组元素 mykey2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey2</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2	# 合并两组 mykey mykey2 =&gt;mykey3 并集</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey3	# 看并集的数量</span><br><span class="line">(integer) 15</span><br></pre></td></tr></table></figure>

<p>如果允许容错，那么就可以使用Hyperloglog</p>
<p>如果不允许容错，就使用set或者自己的数据类型即可</p>
<h4 id="BitMaps-位图"><a href="#BitMaps-位图" class="headerlink" title="BitMaps(位图)"></a>BitMaps(位图)</h4><blockquote>
<p>使用位存储，信息状态只有 0 和 1</p>
<p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p>
</blockquote>
<p><strong>应用场景</strong></p>
<p>签到统计、状态统计</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>setbit key offset value</code></td>
<td>为指定key的offset位设置值</td>
</tr>
<tr>
<td><code>getbit key offset</code></td>
<td>获取offset位的值</td>
</tr>
<tr>
<td><code>bitcount key [start end]</code></td>
<td>统计字符串被设置为1的bit数，也可以指定统计范围按字节</td>
</tr>
<tr>
<td><code>bitop operration destkey key[key..]</code></td>
<td>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</td>
</tr>
<tr>
<td><code>BITPOS key bit [start] [end]</code></td>
<td>返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位</td>
</tr>
</tbody></table>
<p>使用bitmap来记录 周一到周日的打卡</p>
<p>周一：1 周二：0 周三：0 周四：1….</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETBIT sign 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT sign 1 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT sign 2 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT sign 3 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT sign 4 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT sign 5 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT sign 6 0</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>查看某一天是否有打卡</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GETBIT sign 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; GETBIT sign 6</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>统计操作，统计 打卡的天数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BITCOUNT sign	# 统计这周的打卡记录，就可以看到是否有全勤</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>==Redis的单条命令是保证原子性的，但是redis事务不能保证原子性==</p>
<blockquote>
<p>Redis事务本质：一组命令的集合。</p>
<p>—————– 队列 set set set 执行 ——————-</p>
<p>事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。</p>
<ul>
<li>一次性</li>
<li>顺序性</li>
<li>排他性</li>
</ul>
<hr>
<ol>
<li>Redis事务没有隔离级别的概念</li>
<li>Redis单条命令是保证原子性的，但是事务不保证原子性！</li>
</ol>
</blockquote>
<p><strong>Redis事务操作过程</strong></p>
<ul>
<li>开启事务（<code>multi</code>）</li>
<li>命令入队</li>
<li>执行事务（<code>exec</code>）</li>
</ul>
<p>所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi	# 开启事务</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令入队</span></span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC	# 执行事务</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) "v2"</span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure>

<p><strong>取消事务(discard)</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi	# 开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD	# 取消事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k4	# 事务队列中命令都不会被执行</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p><strong>事务错误</strong></p>
<blockquote>
<p>编译时异常(代码有问题，命令有错！），事务中所有的命令都不会执行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; getset k3	# 错误的命令</span><br><span class="line">(error) ERR wrong number of arguments for 'getset' command</span><br><span class="line">127.0.0.1:6379&gt; set k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k5 v5</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec	# 执行事务时报错</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get k5	# 所有的命令都不会执行</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 运行时异常代码（比如1/0的情况）逻辑错误，但事务中 *<em>其他命令可以正常执行 *</em> &gt;&gt;&gt; 所以不保证事务原子性</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 "v1"</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCR k1		# 会执行的时候失败</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an integer or out of range	# 虽然第二条命令报错了，但是依旧正常执行成功了</span><br><span class="line">3) OK</span><br><span class="line">4) OK</span><br><span class="line">5) "v3"</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">"v2"</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">"v3"</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>监控</strong>     Watch（面试常问）</p>
</blockquote>
<p><strong>悲观锁：</strong></p>
<ul>
<li>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</li>
</ul>
<p><strong>乐观锁：</strong></p>
<ul>
<li>很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li>
<li>获取version</li>
<li>更新的时候比较version</li>
</ul>
<p>使用<code>watch key</code>监控指定数据，相当于乐观锁加锁。</p>
<blockquote>
<p>正常执行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money	# 监视 watch 对象</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) (integer) 80</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion）</p>
</blockquote>
<p>我们启动另外一个客户端模拟插队线程。</p>
<p>线程1：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money		# 监视 money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY out 10</span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure>

<p>模拟线程插队，线程2：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get money</span><br><span class="line">"80"</span><br><span class="line">127.0.0.1:6379&gt; set money 1000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>回到线程1，执行事务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXEC	# 执行之前，另外一个线程2，修改了值，这个时候，就会导致事务执行失败+</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>如果修改失败，解锁获取最新值，然后再加锁进行事务。</p>
<p><code>unwatch</code>进行解锁。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; UNWATCH		# 先解锁</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; WATCH money	# 获取最新的值，再次监视，	select version</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY money 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC	# 跟监视的值比较是否发生了变化，如果没有变化，那么可以执行成功，如果变化就执行失败</span><br><span class="line">1) (integer) 999</span><br><span class="line">2) (integer) 1000</span><br></pre></td></tr></table></figure>

<h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。如果要使用java操作redis，那么就一定要对jedis十分的熟悉</p>
<p>1、导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入jedis的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--fastjson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.70<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、编码测试</p>
<ul>
<li>连接数据库</li>
<li>操作命令</li>
<li>断开连接</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.carey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、new Jedis对象即可</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//Jedis所有的命令就是之前学习的所有指令</span></span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<img src="/blog/2020/09/02/redis/image-20200907214034031.png" class>

<p><strong>常用的API</strong></p>
<hr>
<p>String</p>
<p>List</p>
<p>Set</p>
<p>Hash</p>
<p>Zset</p>
<blockquote>
<p>所有的api命令，就是我们对应的上面学习的指令，一个都没有变化</p>
</blockquote>
<p><strong>事务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.carey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        jedis.flushDB();</span><br><span class="line"></span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">        jsonObject.put(<span class="string">"name"</span>,<span class="string">"carey"</span>);</span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        Transaction multi = jedis.multi();</span><br><span class="line">        String result = jsonObject.toJSONString();</span><br><span class="line">        <span class="comment">// jedis.watch(result)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">"user1"</span>,result);</span><br><span class="line">            multi.set(<span class="string">"user2"</span>,result);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>; <span class="comment">// 代码抛出异常，事务执行失败</span></span><br><span class="line">            multi.exec();   <span class="comment">//执行事务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            multi.discard();    <span class="comment">//放弃事务</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(jedis.get(<span class="string">"user1"</span>));</span><br><span class="line">            System.out.println(jedis.get(<span class="string">"user2"</span>));</span><br><span class="line">            jedis.close();  <span class="comment">//关闭连接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h3><p>1.导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。</p>
<p>jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式</p>
<p>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式</p>
<p>我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。</p>
<img src="/blog/2020/09/02/redis/image-20200908155357565.png" class>

<p>查看RedisAutoConfiguration源码可知还有RedisProperties类</p>
<img src="/blog/2020/09/02/redis/image-20200908155445779.png" class>

<p>前面说SpringBoot2.x后默认使用Lettuce来替换Jedis，可以通过源码进行验证:</p>
<p>先看Jedis</p>
<img src="/blog/2020/09/02/redis/image-20200908202135475.png" class>

<p>@ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的</p>
<p>再看Lettuce</p>
<img src="/blog/2020/09/02/redis/image-20200908202214526.png" class>

<p>完美生效，没有问题</p>
<p>回看RedisAutoConfiguration</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"redisTemplate"</span>)	<span class="comment">//我们可以自己定义一个redisTemplate来替换这个默认的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="comment">// 默认的RedisTemplate没有过多的设置，redis对象都是需要序列化</span></span><br><span class="line">        <span class="comment">// 两个泛型都是Object，Object的类型，我们后面使用需要强制转换&lt;String,Object&gt;</span></span><br><span class="line">       RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">       template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">       <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span> <span class="comment">// 由于String是redis中最常使用的类型，所以说单独提出来一个bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">       StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">       template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">       <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>只有两个简单的Bean</p>
<ul>
<li><strong>RedisTemplate</strong></li>
<li><strong>StringRedisTemplate</strong></li>
</ul>
<p>当看到xxTemplate时可以对比RestTemplate、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。</p>
<p>在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的</p>
<p>说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties</p>
<img src="/blog/2020/09/02/redis/image-20200908202535629.png" class>

<p>基本的属性配置：</p>
<img src="/blog/2020/09/02/redis/image-20200908202614676.png" class>

<p>还有一些连接池相关的配置。注意使用时一定使用Lettuce的连接池。</p>
<img src="/blog/2020/09/02/redis/image-20200908202708524.png" class>

<p>2.配置连接</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置redis</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>

<p>3.测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.carey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis02SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// redisTemplate    操作不同的数据类型，api和我们的指令是一样的</span></span><br><span class="line">        <span class="comment">// opsForValue 操作字符串 类似String</span></span><br><span class="line">        <span class="comment">// opsForList 操作List    类似List</span></span><br><span class="line">        <span class="comment">// opsForSet</span></span><br><span class="line">        <span class="comment">// opsForHash</span></span><br><span class="line">        <span class="comment">// opsForZSet</span></span><br><span class="line">        <span class="comment">// opsForGeo</span></span><br><span class="line">        <span class="comment">// opsForHyperLogLog</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span></span><br><span class="line"><span class="comment">//        connection.flushDb();</span></span><br><span class="line"><span class="comment">//        connection.flushAll();</span></span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"mykey"</span>,<span class="string">"陈同学学Java"</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">"mykey"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<img src="/blog/2020/09/02/redis/image-20200908204416214.png" class>

<img src="/blog/2020/09/02/redis/image-20200908204431764.png" class>

<p>在程序中可以正常输出，但是数据出现了乱码</p>
<p> 这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。</p>
<p>我们转到看那个默认的RedisTemplate内部什么样子：</p>
<img src="/blog/2020/09/02/redis/image-20200908204714254.png" class>

<p>在最开始就能看到几个关于序列化的参数。</p>
<p>默认的序列化器是采用JDK序列化器</p>
<img src="/blog/2020/09/02/redis/image-20200908205004188.png" class>

<p>而默认的RedisTemplate中的所有序列化器都是使用这个序列化器：</p>
<img src="/blog/2020/09/02/redis/image-20200908205103740.png" class>

<p>后续我们定制RedisTemplate就可以对其进行修改。</p>
<p><code>RedisSerializer</code>提供了多种序列化方案：</p>
<ul>
<li>直接调用RedisSerializer的静态方法来返回序列化器，然后set</li>
</ul>
<img src="/blog/2020/09/02/redis/image-20200908205423139.png" class>

<ul>
<li>自己new 相应的实现类，然后set</li>
</ul>
<ul>
<li><strong>定制RedisTemplate的模板：</strong></li>
</ul>
<p>我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写我们自己的redisTemplate</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="comment">// 将template 泛型设置为 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        <span class="comment">// 连接工厂，不必修改</span></span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 序列化设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// key、hash的key 采用 String序列化方式</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// value、hash的value 采用 Jackson 序列化方式</span></span><br><span class="line">        template.setValueSerializer(RedisSerializer.json());</span><br><span class="line">        template.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，只要实体类进行了序列化，我们存什么都不会有乱码的担忧了。</p>
<h3 id="自定义Redis工具类"><a href="#自定义Redis工具类" class="headerlink" title="自定义Redis工具类"></a>自定义Redis工具类</h3><p>使用RedisTemplate需要频繁调用<code>.opForxxx</code>然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。</p>
<p>工具类参考博客：</p>
<p><a href="https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html" target="_blank" rel="noopener">https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html</a></p>
<p><a href="https://www.cnblogs.com/zhzhlong/p/11434284.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhzhlong/p/11434284.html</a></p>
<h3 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h3><p>Redis启动的时候，就通过配置文件来启动</p>
<blockquote>
<p>单位</p>
</blockquote>
<img src="/blog/2020/09/02/redis/image-20200908210526710.png" class>

<p>配置文件 unit单位 对大小写不敏感，也就是容量单位不区分大小写</p>
<blockquote>
<p>包含</p>
</blockquote>
<img src="/blog/2020/09/02/redis/image-20200908210826638.png" class>

<p>可以使用 include 组合多个配置问题</p>
<blockquote>
<p>网络配置</p>
</blockquote>
<img src="/blog/2020/09/02/redis/image-20200908211219690.png" class>

<blockquote>
<p>通用 GENERAL</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes	# 以守护进程的方式运行，默认是no，我们需要自己开启为yes！</span><br><span class="line"></span><br><span class="line">pidfile /var/run/redis_6379.pid	# 如果以后台的方式运行，我们就需要指定一个pid文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specify the server verbosity level.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This can be one of:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> debug (a lot of information, useful <span class="keyword">for</span> development/testing)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> notice (moderately verbose, what you want <span class="keyword">in</span> production probably)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice</span><br><span class="line">logfile "" # 日志的文件位置名</span><br><span class="line">databases 16	# 数据库的数量，默认是16个数据库</span><br><span class="line">always-show-logo yes	# 是否显示logo</span><br></pre></td></tr></table></figure>

<blockquote>
<p>快照</p>
</blockquote>
<p>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb .aof</p>
<p>由于Redis是基于内存的数据库，如果没有持久化，那么数据断电即失，需要将数据由内存持久化到文件中</p>
<p>持久化方式：</p>
<ul>
<li>RDB</li>
<li>AOF</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果900s内，至少有1个key进行了修改，我们即进行持久化操作</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果300s内，至少有10个key进行了修改，我们即进行持久化操作</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果60s内，至少有10000个key进行了修改，我们即进行持久化操作</span></span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes	# 持久化如果出错，是否还需要继续工作</span><br><span class="line"></span><br><span class="line">rdbcompression yes	# 是否压缩 rdb 文件，需要消耗一些cpu资源</span><br><span class="line"></span><br><span class="line">rdbchecksum yes # 保存rdb文件的时候，进行错误的检查校验</span><br><span class="line"></span><br><span class="line">dir ./	# rdb文件保存的目录</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主从复制</p>
</blockquote>
<img src="/blog/2020/09/02/redis/image-20200908213223828.png" class>

<p>详细见后面的主从复制介绍</p>
<blockquote>
<p>SECURITY 安全</p>
</blockquote>
<img src="/blog/2020/09/02/redis/image-20200908213659767.png" class>

<p>可以在这里设置redis的密码，默认是没有密码的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass	# 获取redis的密码</span><br><span class="line">1) "requirepass"</span><br><span class="line">2) ""</span><br><span class="line">127.0.0.1:6379&gt; config set requirepass "123456"	# 设置redis的密码</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) "requirepass"</span><br><span class="line">2) "123456"</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; auth "123456"	# 使用密码进行登录</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<blockquote>
<p>客户端连接相关</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000  # 设置能连接上redis的最大客户端数量</span><br><span class="line"></span><br><span class="line">maxmemory &lt;bytes&gt; # redis配置最大的内存容量</span><br><span class="line"></span><br><span class="line">maxmemory-policy noeviction # 内存达到上限之后的处理策略</span><br><span class="line"><span class="meta">#</span><span class="bash"> maxmemory-policy 六种方式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1、volatile-lru：只对设置了过期时间的key进行LRU（默认值）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、allkeys-lru ： 删除lru算法的key</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、volatile-random：随机删除即将过期key</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、allkeys-random：随机删除</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、volatile-ttl ： 删除即将过期的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6、noeviction ： 永不过期，返回错误</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>APPEND ONLY MODE               aof配置</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendonly no	# 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分情况下，rdb完全够用</span><br><span class="line"></span><br><span class="line">appendfilename "appendonly.aof"	# 持久化的文件夹名字</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync always	<span class="comment"># 每次修改都会sync。消耗性能</span></span></span><br><span class="line">appendfsync everysec	# 每秒执行一次sync，可能会丢失这1s的数据</span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync no		<span class="comment"># 不执行sync，这个时候操作系统自己同步数据，速度最快</span></span></span><br></pre></td></tr></table></figure>

<p>具体看redis持久化</p>
<h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><p>在面试和工作中，持久化是重点</p>
<p>Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失，所以Redis提供了持久化的功能来处理！</p>
<h4 id="RDB（Redis-DataBases）"><a href="#RDB（Redis-DataBases）" class="headerlink" title="RDB（Redis DataBases）"></a>RDB（Redis DataBases）</h4><blockquote>
<p>什么是RDB</p>
</blockquote>
<p>RDB是Redis用来进行持久化的一种方式，在指定的时间间隔把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里。</p>
<img src="/blog/2020/09/02/redis/graphviz-cd96bfa5c61ef2b8dd69a9b0a97cde047cb722a8.svg" class>

<p>默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p>
<p><strong>工作原理</strong></p>
<hr>
<p>在进行 <strong><code>RDB</code></strong> 的时候，<strong><code>redis</code></strong> 的主线程是不会做 <strong><code>io</code></strong> 操作的，主线程会 <strong><code>fork</code></strong> 一个子线程来完成该操作；</p>
<ol>
<li>Redis 调用forks。同时拥有父进程和子进程。</li>
<li>子进程将数据集写入到一个临时 RDB 文件中。</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li>
</ol>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</p>
<img src="/blog/2020/09/02/redis/20200513215141519.jpg" class>

<p>rdb默认保存在dump.rdb中</p>
<img src="/blog/2020/09/02/redis/image-20200909100642105.png" class>

<p><strong>触发机制</strong></p>
<hr>
<ol>
<li>save的规则满足的情况下，会自动触发rdb原则</li>
<li>执行flushall命令，也会触发我们的rdb原则</li>
<li>退出redis，也会自动产生rdb文件</li>
</ol>
<p>备份就自动生成一个dump.rdb</p>
<p><img src="/blog/blog/.com/2020/09/02/redis/image-20200914150922307.png" alt="image-20200914150922307"></p>
<blockquote>
<p>如何恢复rdb文件</p>
</blockquote>
<p>1、只需要将rdb文件放在redis启动目录就可以了，redis启动的时候会自动检查dump.rdb恢复其中的数据</p>
<p>2、查看需要存在的位置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">1) "dir"</span><br><span class="line">2) "/usr/local/bin"		# 如果在这个目录下存在dump.rdb文件，启动就会自动恢复其中的数据</span><br></pre></td></tr></table></figure>

<h5 id="触发持久化规则"><a href="#触发持久化规则" class="headerlink" title="触发持久化规则"></a>触发持久化规则</h5><p>满足配置条件中的触发条件 ；</p>
<p>可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。</p>
<img src="/blog/2020/09/02/redis/redis%E6%8C%81%E4%B9%85%E5%8C%961.jpg" class>

<h5 id="save"><a href="#save" class="headerlink" title="save"></a>save</h5><p>使用 <code>save</code> 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；</p>
<p>由于 <code>save</code> 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，<code>save</code>命令执行速度会非常慢，阻塞所有客户端的请求。</p>
<img src="/blog/2020/09/02/redis/redis%E6%8C%81%E4%B9%85%E5%8C%962.jpg" class>

<h5 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h5><p><code>flushall</code> 命令也会触发持久化 ；</p>
<h5 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h5><p><code>bgsave</code> 是异步进行，进行持久化的时候，<code>redis</code> 还可以将继续响应客户端请求 ；</p>
<img src="/blog/2020/09/02/redis/redis%E6%8C%81%E4%B9%85%E5%8C%963.jpg" class>

<p><strong>bgsave和save对比</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody><tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞？</td>
<td>是</td>
<td>是（阻塞发生在fock()，通常非常快）</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外的内存</td>
<td>不阻塞客户端命令</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端命令</td>
<td>需要fock子进程，消耗内存</td>
</tr>
</tbody></table>
<h5 id="RDB的优缺点"><a href="#RDB的优缺点" class="headerlink" title="RDB的优缺点"></a>RDB的优缺点</h5><p><strong>优点：</strong></p>
<ol>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性要求不高</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。</li>
<li>fork进程的时候，会占用一定的内容空间。</li>
</ol>
<h4 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h4><p>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍</p>
<p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<p>==AOF保存的是appendonly.aof文件==</p>
<p><img src="/blog/blog/.com/2020/09/02/redis/image-20200914153642177.png" alt="image-20200914153642177"></p>
<p><code>appendonly yes</code>表示启用AOF</p>
<p>默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！</p>
<p>如果这个aof文件有错位，这时候redis是启动不起来的，如下图的情况所示</p>
<p><img src="/blog/blog/.com/2020/09/02/redis/image-20200914154947561.png" alt="image-20200914154947561">        这时我们需要修复这个aof文件</p>
<p>redis给我们提供了一个工具<code>redis-check-aof --fix</code></p>
<p><img src="/blog/blog/.com/2020/09/02/redis/image-20200914155131741.png" alt="image-20200914155131741"></p>
<p>如果文件正常，重启就可以直接恢复了</p>
<p><img src="/blog/blog/.com/2020/09/02/redis/image-20200914155316232.png" alt="image-20200914155316232"></p>
<h5 id="重写规则说明"><a href="#重写规则说明" class="headerlink" title="重写规则说明"></a>重写规则说明</h5><p>aof默认就是文件的无限追加，文件会越来越大</p>
<p><img src="/blog/blog/.com/2020/09/02/redis/image-20200914160314727.png" alt="image-20200914160314727"></p>
<p>图片中的意思是如果aof文件大于64m，太大了，fork一个新的进程来将我们的文件进行重写</p>
<h5 id="AOF的优缺点"><a href="#AOF的优缺点" class="headerlink" title="AOF的优缺点"></a>AOF的优缺点</h5><p><strong>配置文件内容</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly no	# 默认是不开启aof模式的，默认是使用rdb方式持久化，在大部分情况下，rdb完全够用</span><br><span class="line">appendfilename "appendonly.aof"	# 持久化的文件的名字</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync always	<span class="comment"># 每次修改都会sync。消耗性能</span></span></span><br><span class="line">appendfsync everysec	# 每秒执行一次sync。可能会丢失这1秒的数据</span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync no		<span class="comment"># 不执行sync，这个时候操作系统自己同步数据，速度最快</span></span></span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ol>
<li>每一次修改都会同步，文件的完整性会更加好</li>
<li>每秒同步一次，可能会丢失一秒的数据</li>
<li>从不同步，效率最高的</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>相对于数据文件来说，aof远远大于rdb，修复速度也比rdb慢！</li>
<li>aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li>
</ol>
<h4 id="RDB和AOP选择"><a href="#RDB和AOP选择" class="headerlink" title="RDB和AOP选择"></a>RDB和AOP选择</h4><p><strong>RDB 和 AOF 对比</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
</tbody></table>
<p><strong>如何选择使用哪种持久化方式？</strong></p>
<p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p>
<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p>
<h3 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h3><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<img src="/blog/2020/09/02/redis/pubsub1.png" class>

<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<img src="/blog/2020/09/02/redis/pubsub2.png" class>

<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>下表列出了 redis 发布订阅常用命令：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.redis.net.cn/order/3632.html" target="_blank" rel="noopener">PSUBSCRIBE pattern [pattern …]</a> 订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">[PUBSUB subcommand [argument [argument …]]](<a href="https://www.redis.net.cn/order/3633.html" target="_blank" rel="noopener">https://www.redis.net.cn/order/3633.html</a>) 查看订阅与发布系统状态。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.redis.net.cn/order/3634.html" target="_blank" rel="noopener">PUBLISH channel message</a> 将信息发送到指定的频道。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">[PUNSUBSCRIBE [pattern [pattern …]]](<a href="https://www.redis.net.cn/order/3635.html" target="_blank" rel="noopener">https://www.redis.net.cn/order/3635.html</a>) 退订所有给定模式的频道。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.redis.net.cn/order/3636.html" target="_blank" rel="noopener">SUBSCRIBE channel [channel …]</a> 订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">[UNSUBSCRIBE [channel [channel …]]](<a href="https://www.redis.net.cn/order/3637.html" target="_blank" rel="noopener">https://www.redis.net.cn/order/3637.html</a>) 指退订给定的频道。</td>
</tr>
</tbody></table>
<p>这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等</p>
<blockquote>
<p><strong>测试</strong></p>
</blockquote>
<p>订阅端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE chenqingxue		<span class="comment">#订阅一个频道 chenqingxue</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"chenqingxue"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 等待读取推送的信息</span></span><br><span class="line">1) <span class="string">"message"</span>	<span class="comment"># 消息</span></span><br><span class="line">2) <span class="string">"chenqingxue"</span>	<span class="comment"># 哪个频道的消息</span></span><br><span class="line">3) <span class="string">"hello,chenqing"</span>	<span class="comment"># 消息的具体内容</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"message"</span></span><br><span class="line">2) <span class="string">"chenqingxue"</span></span><br><span class="line">3) <span class="string">"hello,redis"</span></span><br></pre></td></tr></table></figure>

<p>发送端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH chenqingxue <span class="string">"hello,chenqing"</span>	<span class="comment"># 发布者发布消息到频道 </span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH chenqingxue <span class="string">"hello,redis"</span>	<span class="comment"># 发布者发布消息到频道 </span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 <code>redis.h/redisServer</code> 结构， 结构的 <code>pubsub_channels</code> 属性是一个字典， 这个字典就用于保存订阅频道的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    dict *pubsub_channels;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p>
<img src="/blog/2020/09/02/redis/%E8%AE%A2%E9%98%85%E5%8E%9F%E7%90%86.png" class>

<p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>1、实时消息系统</p>
<p>2、实时聊天（频道当作聊天室，将信息回显给所有人）</p>
<p>3、订阅，关注系统等等</p>
<p>稍微复杂的场景我们就会使用消息中间件MQ（消息队列）处理</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>订阅信息由服务器进程维持的 <code>redisServer.pubsub_channels</code> 字典保存，字典的键为被订阅的频道，字典的值为订阅频道的所有客户端。</li>
<li>当有新消息发送到频道时，程序遍历频道（键）所对应的（值）所有客户端，然后将消息发送到所有订阅频道的客户端上。</li>
<li>订阅模式的信息由服务器进程维持的 <code>redisServer.pubsub_patterns</code> 链表保存，链表的每个节点都保存着一个 <code>pubsubPattern</code> 结构，结构中保存着被订阅的模式，以及订阅该模式的客户端。程序通过遍历链表来查找某个频道是否和某个模式匹配。</li>
<li>当有新消息发送到频道时，除了订阅频道的客户端会收到消息之外，所有订阅了匹配频道的模式的客户端，也同样会收到消息。</li>
<li>退订频道和退订模式分别是订阅频道和订阅模式的反操作。</li>
</ul>
<h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p>
<img src="/blog/2020/09/02/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" class>

<p>默认情况下，每台Redis服务器都是主节点，且一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>读写分离：可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；</li>
<li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ol>
<h4 id="为什么使用集群"><a href="#为什么使用集群" class="headerlink" title="为什么使用集群"></a>为什么使用集群</h4><ol>
<li>单台服务器难以负载大量的请求</li>
<li>单台服务器故障率高，系统崩坏概率大</li>
<li>单台服务器内存容量有限。</li>
</ol>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>只配置从库，不用配置主库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication <span class="comment"># 查看当前库的信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master		<span class="comment"># 角色： master</span></span><br><span class="line">connected_slaves:0	<span class="comment"># 0表示没有从机</span></span><br><span class="line">master_replid:1e409d49546b0f59896450eee7b1f2578cb38d16</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>

<p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：</p>
<ul>
<li>端口号</li>
<li>pid名字</li>
<li>日志文件名</li>
<li>rdb文件名</li>
</ul>
<p>修改后启动我们的三个redis服务器，可以通过进程信息查看：</p>
<img src="/blog/2020/09/02/redis/%E5%90%AF%E5%8A%A86379.png" class>

<img src="/blog/2020/09/02/redis/%E5%90%AF%E5%8A%A86380.png" class>

<img src="/blog/2020/09/02/redis/%E5%90%AF%E5%8A%A86381.png" class>

<img src="/blog/2020/09/02/redis/%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF.png" class>

<h4 id="常用策略"><a href="#常用策略" class="headerlink" title="常用策略"></a>常用策略</h4><h5 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h5><p>此一主二从 可以水平扩展为一主多从，主机主要负责写，从机主要负责读</p>
<p>==默认情况下，每台Redis服务器都是主节点；==我们一般情况下只用配置从机就好了！</p>
<p>认老大！一主（79）二从（80，81）</p>
<p>使用<code>SLAVEOF host port</code>就可以为从机配置主机了。</p>
<img src="/blog/2020/09/02/redis/%E9%85%8D%E7%BD%AE%E4%BB%8E%E6%9C%BA.png" class>

<p>然后主机上也能看到从机的状态：</p>
<img src="/blog/2020/09/02/redis/%E6%9F%A5%E7%9C%8Breplication%E9%85%8D%E7%BD%AE.png" class>

<p>然后按上述步骤继续配置第二台从机</p>
<p>如果两个都配置完了，就是有两个从机的</p>
<img src="/blog/2020/09/02/redis/%E6%9F%A5%E7%9C%8Breplication%E9%85%8D%E7%BD%AE2.png" class>

<p>我们这里是使用命令搭建，是暂时的；==真实开发中应该在从机的配置文件中进行配置，==这样的话才是永久的。</p>
<img src="/blog/2020/09/02/redis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AEreplication.png" class>

<h5 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h5><img src="/blog/2020/09/02/redis/%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0.png" class>

<p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力。</p>
<p>第一个开头的事master，其他都是slave，只是中间的slave是下一个的master</p>
<h4 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h4><p>1、从机只能读，不能写，主机可读可写但是多用于写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主机	6379</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从机	6380</span></span><br><span class="line">127.0.0.1:6380&gt; keys *</span><br><span class="line">1) <span class="string">"k1"</span></span><br><span class="line">127.0.0.1:6380&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">(error) READONLY You can<span class="string">'t write against a read only replica.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从机	6381</span></span><br><span class="line">127.0.0.1:6381&gt; keys *</span><br><span class="line">1) <span class="string">"k1"</span></span><br><span class="line">127.0.0.1:6381&gt; get k1</span><br><span class="line"><span class="string">"v1"</span></span><br><span class="line">127.0.0.1:6381&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">(error) READONLY You can<span class="string">'t write against a read only replica.</span></span><br></pre></td></tr></table></figure>

<p>2、当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p>
<p>3、当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。</p>
<p>4、第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p>
<ul>
<li>从机手动执行命令<code>slaveof no one</code>,这样执行以后从机会独立出来成为一个主机</li>
<li>使用哨兵模式（自动选举）</li>
</ul>
<h4 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h4><p>Slave启动成功连接到master后会发送一个sync同步命令</p>
<p>Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<strong>master将传送整个数据文件到slave，并完成一次完全同步</strong></p>
<ul>
<li><strong>全量复制</strong>：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li><strong>增量复制</strong>：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li>
</ul>
<p><strong>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</strong></p>
<blockquote>
<p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p>
</blockquote>
<p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么就重新连接！</p>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>详解查看：<a href="https://www.jianshu.com/p/06ab9daf921d" target="_blank" rel="noopener">https://www.jianshu.com/p/06ab9daf921d</a></p>
<p>（自动选举老大的模式）</p>
<h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p><strong>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。</strong>这不是一种推荐的方式，更多时候，我们优先考虑<strong>哨兵模式</strong>。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong></p>
<img src="/blog/2020/09/02/redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" class>

<p>这里的哨兵有两个作用</p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<p>用文字描述一下<strong>故障切换（failover）</strong>的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p>
<img src="/blog/2020/09/02/redis/%E5%A4%9A%E5%93%A8%E5%85%B5%E7%9B%91%E6%8E%A7Redis.png" class>

<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p><strong>以一主二从的策略为例:</strong></p>
<p>1、自定义的/cxxqingconfig目录下新建sentinel.conf文件，名字绝不能错，然后配置哨兵sentinel.conf，填写内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 1</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>

<p>后面的最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数最多的，就会成为主机！</p>
<p>2、启动哨兵</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@cxxqing bin]<span class="comment"># redis-sentinel cxxqingconfig/sentinel.conf </span></span><br><span class="line">14363:X 03 Oct 2020 17:04:04.947 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">14363:X 03 Oct 2020 17:04:04.947 <span class="comment"># Redis version=6.0.7, bits=64, commit=00000000, modified=0, pid=14363, just started</span></span><br><span class="line">14363:X 03 Oct 2020 17:04:04.947 <span class="comment"># Configuration loaded</span></span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ <span class="string">''</span>-._                                             </span><br><span class="line">      _.-``    `.  `_.  <span class="string">''</span>-._           Redis 6.0.7 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">''</span>-._                                   </span><br><span class="line"> (    <span class="string">'      ,       .-`  | `,    )     Running in sentinel mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|'</span>` _.-<span class="string">'|     Port: 26379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-'</span>    |     PID: 14363</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">'    _.-'</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">'    _.-'</span>_.-<span class="string">'|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-'</span>_.-<span class="string">'    |           http://redis.io        </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-'</span>_.-<span class="string">'    _.-'</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">'    _.-'</span>_.-<span class="string">'|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-'</span>_.-<span class="string">'    |                                  </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-'</span>_.-<span class="string">'    _.-'</span>                                   </span><br><span class="line">      `-._    `-.__.-<span class="string">'    _.-'</span>                                       </span><br><span class="line">          `-._        _.-<span class="string">'                                           </span></span><br><span class="line"><span class="string">              `-.__.-'</span>                                               </span><br><span class="line"></span><br><span class="line">14363:X 03 Oct 2020 17:04:04.948 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">14363:X 03 Oct 2020 17:04:04.949 <span class="comment"># Sentinel ID is 04e2e2fd0b2a7f783b27004de070b0c996981ef0</span></span><br><span class="line">14363:X 03 Oct 2020 17:04:04.949 <span class="comment"># +monitor master myredis 127.0.0.1 6379 quorum 1</span></span><br></pre></td></tr></table></figure>

<p>正常主从演示，原有的master挂了</p>
<img src="/blog/2020/09/02/redis/%E5%93%A8%E5%85%B5%E6%B5%8B%E8%AF%95%E6%8C%82%E6%96%AD%E4%B8%BB%E6%9C%BA.png" class>

<p>如果Master节点断开了，这个时候就会从从机中随机选择一个服务器！（这里面有一个投票算法）</p>
<p>过了一会儿后<strong>info replication</strong>查看</p>
<img src="/blog/2020/09/02/redis/%E5%93%A8%E5%85%B5%E6%8A%95%E7%A5%A8.png" class>

<p><strong>原有的down掉主机Master如果恢复运转，只能轮为从机Slave</strong></p>
<img src="/blog/2020/09/02/redis/%E4%B8%BB%E6%9C%BA%E5%9B%9E%E6%9D%A5%E5%90%8E%E5%8F%98%E4%BB%8E%E6%9C%BA.png" class>

<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>优点：</strong></p>
<ol>
<li>哨兵集群，基于主从复制模式，所有主从复制的优点，它都有</li>
<li>主从可以切换，故障可以转移，系统的可用性更好</li>
<li>哨兵模式是主从模式的升级，手动到自动，更加健壮</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li>
</ol>
<h5 id="哨兵模式的全部配置"><a href="#哨兵模式的全部配置" class="headerlink" title="哨兵模式的全部配置"></a>哨兵模式的全部配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span></span><br><span class="line"><span class="comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span></span><br><span class="line"><span class="comment">#一个是事件的类型，</span></span><br><span class="line"><span class="comment">#一个是事件的描述。</span></span><br><span class="line"><span class="comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure>

<h3 id="Redis缓存穿透与雪崩"><a href="#Redis缓存穿透与雪崩" class="headerlink" title="Redis缓存穿透与雪崩"></a>Redis缓存穿透与雪崩</h3><p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p>
<p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p>
<h4 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p><strong>（1）布隆过滤器</strong></p>
<p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，当用户想要查询的时候，使用布隆过滤器在控制层先进行校验，发现不在集合中，就直接丢弃，不再对持久层查询，从而避免了对底层存储系统的查询压力。</p>
<img src="/blog/2020/09/02/redis/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.jpeg" class>

<p><strong>（2）缓存空对象</strong></p>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p>
<img src="/blog/2020/09/02/redis/%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1.jpg" class>

<p>但是这种方法会存在两个问题：</p>
<p>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
<h4 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><p><strong>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</strong></p>
<p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导致数据库瞬间压力过大。</p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p><strong>（1）设置热点数据永不过期</strong></p>
<p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p>
<p><strong>（2）加互斥锁(分布式锁)</strong></p>
<p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><p>缓存雪崩是指，缓存层出现了错误，不能正常工作了(在某一个时间段，缓存集中过期失效)。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。</p>
<img src="/blog/2020/09/02/redis/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.jpg" class>

<h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><p><strong>（1）redis高可用</strong></p>
<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。</p>
<p><strong>（2）限流降级</strong></p>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p><strong>（3）数据预热</strong></p>
<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 </p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Carey
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://cxxqing.github.io/blog/.com/2020/09/02/redis/" title="redis">https://cxxqing.github.io/blog/.com/2020/09/02/redis/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2020/08/08/jvm/" rel="prev" title="jvm">
      <i class="fa fa-chevron-left"></i> jvm
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2020/09/22/maven/" rel="next" title="maven">
      maven <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis学习"><span class="nav-number">1.</span> <span class="nav-text">Redis学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Nosql概述"><span class="nav-number">1.1.</span> <span class="nav-text">Nosql概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么使用Nosql"><span class="nav-number">1.1.1.</span> <span class="nav-text">为什么使用Nosql</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是NoSQL"><span class="nav-number">1.1.2.</span> <span class="nav-text">什么是NoSQL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阿里巴巴演进分析"><span class="nav-number">1.1.3.</span> <span class="nav-text">阿里巴巴演进分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nosql的四大分类"><span class="nav-number">1.1.4.</span> <span class="nav-text">Nosql的四大分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis入门"><span class="nav-number">1.2.</span> <span class="nav-text">Redis入门</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述"><span class="nav-number">1.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows安装"><span class="nav-number">1.2.2.</span> <span class="nav-text">Windows安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux安装"><span class="nav-number">1.2.3.</span> <span class="nav-text">Linux安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试性能"><span class="nav-number">1.2.4.</span> <span class="nav-text">测试性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基础知识"><span class="nav-number">1.2.5.</span> <span class="nav-text">基础知识</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五大数据类型"><span class="nav-number">1.3.</span> <span class="nav-text">五大数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-Key"><span class="nav-number">1.3.1.</span> <span class="nav-text">Redis-Key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-字符串"><span class="nav-number">1.3.2.</span> <span class="nav-text">String(字符串)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List-列表"><span class="nav-number">1.3.3.</span> <span class="nav-text">List(列表)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set-集合"><span class="nav-number">1.3.4.</span> <span class="nav-text">Set(集合)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash（哈希）"><span class="nav-number">1.3.5.</span> <span class="nav-text">Hash（哈希）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Zset（有序集合）"><span class="nav-number">1.3.6.</span> <span class="nav-text">Zset（有序集合）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三种特殊数据类型"><span class="nav-number">1.4.</span> <span class="nav-text">三种特殊数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Geospatial-地理位置"><span class="nav-number">1.4.1.</span> <span class="nav-text">Geospatial(地理位置)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hyperloglog-基数统计"><span class="nav-number">1.4.2.</span> <span class="nav-text">Hyperloglog(基数统计)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BitMaps-位图"><span class="nav-number">1.4.3.</span> <span class="nav-text">BitMaps(位图)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务"><span class="nav-number">1.5.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Jedis"><span class="nav-number">1.6.</span> <span class="nav-text">Jedis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringBoot整合"><span class="nav-number">1.7.</span> <span class="nav-text">SpringBoot整合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义Redis工具类"><span class="nav-number">1.8.</span> <span class="nav-text">自定义Redis工具类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-conf详解"><span class="nav-number">1.9.</span> <span class="nav-text">Redis.conf详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis持久化"><span class="nav-number">1.10.</span> <span class="nav-text">Redis持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB（Redis-DataBases）"><span class="nav-number">1.10.1.</span> <span class="nav-text">RDB（Redis DataBases）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#触发持久化规则"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">触发持久化规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#save"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">save</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#flushall命令"><span class="nav-number">1.10.1.3.</span> <span class="nav-text">flushall命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bgsave"><span class="nav-number">1.10.1.4.</span> <span class="nav-text">bgsave</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDB的优缺点"><span class="nav-number">1.10.1.5.</span> <span class="nav-text">RDB的优缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF（Append-Only-File）"><span class="nav-number">1.10.2.</span> <span class="nav-text">AOF（Append Only File）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#重写规则说明"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">重写规则说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AOF的优缺点"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">AOF的优缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB和AOP选择"><span class="nav-number">1.10.3.</span> <span class="nav-text">RDB和AOP选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis发布订阅"><span class="nav-number">1.11.</span> <span class="nav-text">Redis发布订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令"><span class="nav-number">1.11.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原理"><span class="nav-number">1.11.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景"><span class="nav-number">1.11.3.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">1.11.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis主从复制"><span class="nav-number">1.12.</span> <span class="nav-text">Redis主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念"><span class="nav-number">1.12.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#作用"><span class="nav-number">1.12.2.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么使用集群"><span class="nav-number">1.12.3.</span> <span class="nav-text">为什么使用集群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#环境配置"><span class="nav-number">1.12.4.</span> <span class="nav-text">环境配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用策略"><span class="nav-number">1.12.5.</span> <span class="nav-text">常用策略</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一主二从"><span class="nav-number">1.12.5.1.</span> <span class="nav-text">一主二从</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#薪火相传"><span class="nav-number">1.12.5.2.</span> <span class="nav-text">薪火相传</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用规则"><span class="nav-number">1.12.6.</span> <span class="nav-text">使用规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复制原理"><span class="nav-number">1.12.7.</span> <span class="nav-text">复制原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哨兵模式"><span class="nav-number">1.12.8.</span> <span class="nav-text">哨兵模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述-1"><span class="nav-number">1.12.8.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#测试"><span class="nav-number">1.12.8.2.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优缺点"><span class="nav-number">1.12.8.3.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#哨兵模式的全部配置"><span class="nav-number">1.12.8.4.</span> <span class="nav-text">哨兵模式的全部配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis缓存穿透与雪崩"><span class="nav-number">1.13.</span> <span class="nav-text">Redis缓存穿透与雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存穿透（查不到）"><span class="nav-number">1.13.1.</span> <span class="nav-text">缓存穿透（查不到）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述-2"><span class="nav-number">1.13.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解决方案"><span class="nav-number">1.13.1.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存击穿（量太大，缓存过期）"><span class="nav-number">1.13.2.</span> <span class="nav-text">缓存击穿（量太大，缓存过期）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述-3"><span class="nav-number">1.13.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解决方案-1"><span class="nav-number">1.13.2.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存雪崩"><span class="nav-number">1.13.3.</span> <span class="nav-text">缓存雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述-4"><span class="nav-number">1.13.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解决方案-2"><span class="nav-number">1.13.3.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Carey"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Carey</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Cxxqing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Cxxqing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Carey</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">622k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9:26</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>

<script src="/blog/js/bookmark.js"></script>


  <script defer src="/blog/lib/three/three.min.js"></script>
    <script defer src="/blog/lib/three/three-waves.min.js"></script>


  




  
<script src="/blog/js/local-search.js"></script>













  

  

</body>
</html>
